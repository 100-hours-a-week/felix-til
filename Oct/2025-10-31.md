## 📆 2025-10-31

### 🔔 스크럼

```
오늘 할 일
✔️ 딥다이브
✔️ 세션 인증/인가 프론트엔드 구현 완료 및 연동 확인
```
```
어제 한 일
✔️ Auth 수업내용 복습
- 인증과 인가의 분리
- Resource Owner, Client, Authorization Server, Resource Server
✔️ 비즈니스 예외 처리 User, Comment, Auth 완료
- Global Exception Handler 에서 BadReqeustException, NotFoundException, ForbiddenException으로 공통 예외처리
✔️ 브랜치 생성해서 세션으로 인증/인가 백엔드 구현 완료
- AuthInterceptor 로 HttpServeletReqeust 들어오면 Intercept 처리
- getSession 으로 UUID 사용 대체
```

### 🚀 Today I Learned
#### 대규모 시스템의 세션 인증 
*** Sticky Session ***
```
로드밸런서가 클라이언트의 모든 요청을 최초 세션을 생성한 서버로 고정하여 전송하는 방식

쿠키 -> 웹 서버의 사용자 식별. 세션 데이터를 보유한 적절 서버로 요청을 라우팅
IP 주소 기반 -> 로드 밸런서의 IP 추적으로 동일 IP 요청은 동일한 서버로 전달

장점 -> 사용자 세션의 일관성 제공
단점 -> 부하 분산의 불균형 초래, 특정 서버에 장애가 발생하면 해당 서버의 세션 모두 중단
```

*** Session Clustering ***
```
여러 WAS가 세션 데이터를 공유하여 동일하게 관리하는 방식
Delta Manager -> 모든 서버를 복제
Backup Manager -> 한개만 복제 나머지 서버는 세션ID와 위치 정보만 제공

장점 -> 복제본이 있기 때문에 상대적으로 안전함
단점 -> 네트워크 복잡도 증가 가능성, 메모리 N배 사용
```

*** Redis 세션 저장소 ***
```
세션 정보를 외부 인메모리인 Redis 에 중앙집중식으로 저장하여 모든 서버가 동일한 세션 저장소를 참조

세션 데이터의 특성과 Redis의 특성은 유사

장점 -> 서버 확장시 Redis 연결 정보만 설정하면 되어 간편, 메모리 효율적, 네트워크 트래픽 감소
단점 -> Single Point Of Failure(단일점 한계): redis 장애가 발생하면 전체 서비스 중단
(단일점 문제에 대해서 Redis 클러스터를 구성하거나 redis 샤딩을 이용함)
-> Redis의 메모리 한계 문제

```


### 🗨️ 오늘의 회고
```
완벽한 마무리를 목표로, 포기하면 다시해야한다.
```