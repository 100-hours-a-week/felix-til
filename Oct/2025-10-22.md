## 📆 2025-10-22

### 🔔 스크럼

```
오늘 할 일
✔️ 수업 내용 복습하기
✔️ 이력서 작성 시작해보기
✔️ 6주차 과제
- 커뮤니티 공통 레이아웃 구성 시작해보기, express 서버구축

어제 한 일
✔️ [오늘 나갈 수업내용 복습]
- 테스트 코드 작성
✔️ [이것이 스프링부트다 정독]
- chatper 4. RESTFul API 작성하기 테스트 전까지 완료(50%)
✔️ [코딩테스트 연습]
- 백준 단계별로 풀어보기 4단계 완료
```

### 🚀 Today I Learned
#### 테스트 케이스의 필요성
```
많은 시간이 들어가고 안정성 검증이 어렵기에
테스트 코드는 가성비 있게 작성해야한다.
```
<img src="../images/251022/image.png" height="250" border="1" /></br></br>

#### 스프링에서의 예외처리
```
1. BasicErrorController (기본 예외 처리)
스프링 부트가 기본으로 제공하는 예외 처리 컨트롤러
별도 설정 없이도 예외가 발생하면 자동으로 작동
```
```
2. @ResponseStatus
HTTP 상태 코드를 간단히 변경할 때 사용
정적으로 상태 코드가 고정되며, 동적으로 에러 정보를 전달하기 어려움

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
```
```
3. ResponseStatusException

스프링 5에서 추가된 방식으로, 컨트롤러에서 직접 예외를 던질 수 있음

@GetMapping("/user/{id}")
public User getUser(@PathVariable Long id) {
    return userRepository.findById(id)
        .orElseThrow(() -> new ResponseStatusException(
            HttpStatus.NOT_FOUND, 
            "사용자를 찾을 수 없습니다."
        ));
}
```
```
4. @ExceptionHandler
메서드 레벨에서 특정 예외를 처리, 가장 유연한 방식이지만, 각 컨트롤러마다 중복 코드가 발생가능함

@RestController
public class UserController {
    
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        // 비즈니스 로직
    }
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("USER_NOT_FOUND", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
}
```
</br>

```
5. @RestControllerAdvice (전역 예외 처리)
전역적으로 @ExceptionHandler를 적용하여 모든 컨트롤러의 예외를 한 곳에서 처리

Step 1: ErrorCode 인터페이스 정의
javapublic interface ErrorCode {
    String getCode();
    String getMessage();
    HttpStatus getHttpStatus();
}
```
```
Step 2: 공통 에러 코드와 도메인별 에러 코드

java@Getter
@RequiredArgsConstructor
public enum CommonErrorCode implements ErrorCode {
    INVALID_PARAMETER("COMMON_001", "잘못된 파라미터입니다.", HttpStatus.BAD_REQUEST),
    INTERNAL_SERVER_ERROR("COMMON_002", "서버 내부 오류가 발생했습니다.", HttpStatus.INTERNAL_SERVER_ERROR),
    RESOURCE_NOT_FOUND("COMMON_003", "요청한 리소스를 찾을 수 없습니다.", HttpStatus.NOT_FOUND);
    
    private final String code;
    private final String message;
    private final HttpStatus httpStatus;
}

@Getter
@RequiredArgsConstructor
public enum UserErrorCode implements ErrorCode {
    USER_NOT_FOUND("USER_001", "사용자를 찾을 수 없습니다.", HttpStatus.NOT_FOUND),
    DUPLICATE_EMAIL("USER_002", "이미 존재하는 이메일입니다.", HttpStatus.CONFLICT),
    INVALID_PASSWORD("USER_003", "비밀번호가 일치하지 않습니다.", HttpStatus.UNAUTHORIZED);
    
    private final String code;
    private final String message;
    private final HttpStatus httpStatus;
}
```
```
Step 3: 커스텀 예외 클래스

java@Getter
public class RestApiException extends RuntimeException {
    private final ErrorCode errorCode;
    
    public RestApiException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
    }
    
    public RestApiException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
}
```
```
Step 4: 에러 응답 클래스

java@Getter
@Builder
public class ErrorResponse {
    private String code;
    private String message;
    private LocalDateTime timestamp;
    
    public static ErrorResponse of(ErrorCode errorCode) {
        return ErrorResponse.builder()
            .code(errorCode.getCode())
            .message(errorCode.getMessage())
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    public static ErrorResponse of(ErrorCode errorCode, String message) {
        return ErrorResponse.builder()
            .code(errorCode.getCode())
            .message(message)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```
```
Step 5: RestControllerAdvice 구현

java@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    // 커스텀 예외 처리
    @ExceptionHandler(RestApiException.class)
    public ResponseEntity<ErrorResponse> handleRestApiException(RestApiException e) {
        log.error("RestApiException: {}", e.getMessage(), e);
        ErrorCode errorCode = e.getErrorCode();
        ErrorResponse errorResponse = ErrorResponse.of(errorCode, e.getMessage());
        return ResponseEntity
            .status(errorCode.getHttpStatus())
            .body(errorResponse);
    }
    
    // Validation 예외 처리
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        log.error("Validation error: {}", e.getMessage());
        String message = e.getBindingResult().getAllErrors().get(0).getDefaultMessage();
        ErrorResponse errorResponse = ErrorResponse.of(CommonErrorCode.INVALID_PARAMETER, message);
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(errorResponse);
    }
    
    // 기타 예외 처리
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleException(Exception e) {
        log.error("Unexpected error: {}", e.getMessage(), e);
        ErrorResponse errorResponse = ErrorResponse.of(CommonErrorCode.INTERNAL_SERVER_ERROR);
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(errorResponse);
    }
}

```

### 🔥 오늘의 도전 과제와 해결 방법
<!--
- 오늘의 학습 경험에 대한 자유로운 생각이나 느낀 점을 기록합니다.
- 성공적인 점, 개선해야 할 점, 새롭게 시도하고 싶은 방법 등을 포함할 수 있습니다.-->
```
각 방법의 선택 기준:

BasicErrorController: 기본 동작, 커스터마이징이 필요 없을 때
@ResponseStatus: 간단한 예외의 HTTP 상태만 변경할 때
ResponseStatusException: 빠르게 예외를 던져야 할 때
@ExceptionHandler: 특정 컨트롤러에만 적용할 예외 처리
▶︎ @RestControllerAdvice: 전역 예외 처리 (실무 권장)

실무에서는 @RestControllerAdvice + 커스텀 예외 + ErrorCode 조합이
많이 사용되며 일관된 에러 응답형식과 유지보수성 제공

```
### 🗨️ 오늘의 회고
```
장시간 공부속에서도 효율적인 학습 체득하기
```